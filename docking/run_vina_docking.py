#!/usr/bin/env python3
"""
AutoDock Vina Docking for Top 5 EGFR Inhibitor Candidates
=========================================================
Performs actual molecular docking using Vina 1.2.7
Target: EGFR kinase (PDB: 1M17)
"""

import os
import sys
import subprocess
import tempfile
from pathlib import Path
from typing import Optional, Tuple, List

# RDKit imports
from rdkit import Chem
from rdkit.Chem import AllChem, rdMolTransforms
from rdkit import RDLogger
RDLogger.logger().setLevel(RDLogger.ERROR)

# =============================================================================
# CONFIGURATION
# =============================================================================

VINA_EXE = Path(r"C:\DENOVO\docking\vina_1.2.7_win.exe")
PROTEIN_PDB = Path(r"C:\DENOVO\docking\1M17.pdb")
OUTPUT_DIR = Path(r"C:\DENOVO\docking\vina_results")
LIGAND_DIR = Path(r"C:\DENOVO\results\final_3d\stage2_auto3d_ani2x\sdf")

# EGFR binding site (from Erlotinib co-crystal in 1M17)
# Center coordinates extracted from ligand AQ4
CENTER_X = 22.0
CENTER_Y = 0.3
CENTER_Z = 52.8

# Box size (Angstroms) - covers the ATP binding pocket
BOX_SIZE_X = 25
BOX_SIZE_Y = 25
BOX_SIZE_Z = 25

# Docking parameters
EXHAUSTIVENESS = 32  # Higher = more thorough search
NUM_MODES = 9        # Number of poses to generate
ENERGY_RANGE = 3     # kcal/mol range for poses

# Top 5 candidates (Dock Ranks)
TOP_5_RANKS = [1, 2, 3, 10, 5]  # mol_001, mol_002, mol_003, mol_010, mol_005

TOP_5_SMILES = {
    1: "COc1cc2ncnc(NC3CCC(C(=O)O)CC3)c2cc1OC",
    2: "COc1cc2ncnc(NC3CCCCC3)c2cc1OC",
    3: "COc1ccc(O)c(C(=O)Nc2ccc(C#N)c(C(F)(F)F)c2)c1",
    10: "CN1CCc2c(Nc3ccc(Br)c(Cl)c3)ncnc21",
    5: "CC(=O)Nc1ccc2c(c1)Sc1[nH]c(N(C)C)cc1N2C"
}


# =============================================================================
# PDBQT CONVERSION
# =============================================================================

def mol_to_pdbqt(mol: Chem.Mol, output_path: str) -> bool:
    """Convert RDKit molecule to PDBQT format for Vina."""
    try:
        # Add hydrogens if not present
        mol = Chem.AddHs(mol)
        
        # Generate 3D coordinates if not present
        if mol.GetNumConformers() == 0:
            AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
            AllChem.MMFFOptimizeMolecule(mol)
        
        # Compute Gasteiger charges
        AllChem.ComputeGasteigerCharges(mol)
        
        # Get conformer
        conf = mol.GetConformer()
        
        # AutoDock atom type mapping
        AD_TYPES = {
            'C': 'C', 'N': 'N', 'O': 'O', 'S': 'S', 'P': 'P',
            'F': 'F', 'Cl': 'Cl', 'Br': 'Br', 'I': 'I', 'H': 'H'
        }
        
        pdbqt_lines = []
        pdbqt_lines.append("REMARK  PDBQT generated by RDKit for AutoDock Vina\n")
        pdbqt_lines.append("ROOT\n")
        
        for i, atom in enumerate(mol.GetAtoms()):
            pos = conf.GetAtomPosition(i)
            symbol = atom.GetSymbol()
            
            # Get Gasteiger charge
            try:
                charge = float(atom.GetProp('_GasteigerCharge'))
                if not (-10 < charge < 10):  # Handle NaN or inf
                    charge = 0.0
            except:
                charge = 0.0
            
            # Get AutoDock atom type
            ad_type = AD_TYPES.get(symbol, 'C')
            
            # Handle special cases
            if symbol == 'C':
                # Check if aromatic
                if atom.GetIsAromatic():
                    ad_type = 'A'  # Aromatic carbon
            elif symbol == 'O':
                # Check for hydrogen bond acceptor/donor
                if atom.GetTotalNumHs() > 0:
                    ad_type = 'OA'  # H-bond acceptor
                else:
                    ad_type = 'OA'
            elif symbol == 'N':
                if atom.GetTotalNumHs() > 0:
                    ad_type = 'NA'  # H-bond acceptor with H
                else:
                    ad_type = 'NA'
            elif symbol == 'S':
                ad_type = 'SA'
            elif symbol == 'H':
                # Check if polar hydrogen (attached to N, O, S)
                neighbors = [n.GetSymbol() for n in atom.GetNeighbors()]
                if any(n in ['N', 'O', 'S'] for n in neighbors):
                    ad_type = 'HD'  # Polar hydrogen
                else:
                    ad_type = 'H'
            
            # Format PDBQT ATOM line
            atom_name = f"{symbol}{i+1}"[:4]
            line = f"ATOM  {i+1:5d} {atom_name:<4s} LIG A   1    {pos.x:8.3f}{pos.y:8.3f}{pos.z:8.3f}  1.00  0.00    {charge:+6.3f} {ad_type:<2s}\n"
            pdbqt_lines.append(line)
        
        pdbqt_lines.append("ENDROOT\n")
        pdbqt_lines.append("TORSDOF 0\n")
        
        with open(output_path, 'w') as f:
            f.writelines(pdbqt_lines)
        
        return True
        
    except Exception as e:
        print(f"  Error converting to PDBQT: {e}")
        return False


def prepare_protein_pdbqt(pdb_path: Path, pdbqt_path: Path) -> bool:
    """Prepare protein PDBQT from PDB file."""
    try:
        AD_TYPES = {
            'C': 'C', 'N': 'N', 'O': 'O', 'S': 'S', 'P': 'P',
            'H': 'H', 'FE': 'Fe', 'ZN': 'Zn', 'MG': 'Mg', 'CA': 'Ca'
        }
        
        pdbqt_lines = []
        
        with open(pdb_path, 'r') as f:
            for line in f:
                if line.startswith('ATOM') or line.startswith('HETATM'):
                    # Skip water and ligand
                    res_name = line[17:20].strip()
                    if res_name in ['HOH', 'WAT', 'AQ4', 'ERL']:
                        continue
                    
                    # Get atom type from element
                    if len(line) >= 78:
                        element = line[76:78].strip()
                    else:
                        # Guess from atom name
                        atom_name = line[12:16].strip()
                        element = ''.join(c for c in atom_name if c.isalpha())[:1]
                    
                    ad_type = AD_TYPES.get(element.upper(), 'C')
                    
                    # Add charge field (0.000) and atom type
                    base_line = line[:54].rstrip()
                    pdbqt_line = f"{base_line:54s}  1.00  0.00    +0.000 {ad_type:<2s}\n"
                    pdbqt_lines.append(pdbqt_line)
                elif line.startswith('TER') or line.startswith('END'):
                    pdbqt_lines.append(line)
        
        with open(pdbqt_path, 'w') as f:
            f.writelines(pdbqt_lines)
        
        print(f"âœ“ Protein PDBQT prepared: {pdbqt_path}")
        return True
        
    except Exception as e:
        print(f"Error preparing protein: {e}")
        return False


# =============================================================================
# VINA DOCKING
# =============================================================================

def run_vina_docking(
    ligand_pdbqt: Path,
    protein_pdbqt: Path,
    output_pdbqt: Path,
    log_file: Path
) -> Tuple[bool, float, List[float]]:
    """Run AutoDock Vina docking."""
    
    cmd = [
        str(VINA_EXE),
        "--receptor", str(protein_pdbqt),
        "--ligand", str(ligand_pdbqt),
        "--out", str(output_pdbqt),
        "--center_x", str(CENTER_X),
        "--center_y", str(CENTER_Y),
        "--center_z", str(CENTER_Z),
        "--size_x", str(BOX_SIZE_X),
        "--size_y", str(BOX_SIZE_Y),
        "--size_z", str(BOX_SIZE_Z),
        "--exhaustiveness", str(EXHAUSTIVENESS),
        "--num_modes", str(NUM_MODES),
        "--energy_range", str(ENERGY_RANGE)
    ]
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=600  # 10 minute timeout
        )
        
        # Save log
        with open(log_file, 'w') as f:
            f.write(f"Command: {' '.join(cmd)}\n\n")
            f.write("=== STDOUT ===\n")
            f.write(result.stdout)
            f.write("\n=== STDERR ===\n")
            f.write(result.stderr)
        
        # Parse results
        affinities = []
        for line in result.stdout.split('\n'):
            if line.strip() and line.strip()[0].isdigit():
                parts = line.split()
                if len(parts) >= 2:
                    try:
                        affinity = float(parts[1])
                        affinities.append(affinity)
                    except:
                        pass
        
        if affinities:
            best_affinity = affinities[0]
            return True, best_affinity, affinities
        else:
            return False, 0.0, []
            
    except subprocess.TimeoutExpired:
        print("  Docking timed out")
        return False, 0.0, []
    except Exception as e:
        print(f"  Docking error: {e}")
        return False, 0.0, []


def pdbqt_to_pdb(pdbqt_path: Path, pdb_path: Path, pose_num: int = 1) -> bool:
    """Convert PDBQT output to PDB format (extract specific pose)."""
    try:
        pdb_lines = []
        current_model = 0
        in_target_model = False
        
        with open(pdbqt_path, 'r') as f:
            for line in f:
                if line.startswith('MODEL'):
                    current_model += 1
                    if current_model == pose_num:
                        in_target_model = True
                        pdb_lines.append(line)
                elif line.startswith('ENDMDL'):
                    if in_target_model:
                        pdb_lines.append(line)
                        break
                elif in_target_model:
                    if line.startswith('ATOM') or line.startswith('HETATM'):
                        # Convert PDBQT to PDB (remove charge and AD type columns)
                        pdb_line = line[:66] + '\n'
                        pdb_lines.append(pdb_line)
                    elif line.startswith('ROOT') or line.startswith('ENDROOT') or line.startswith('BRANCH') or line.startswith('ENDBRANCH'):
                        continue  # Skip PDBQT-specific lines
                    else:
                        pdb_lines.append(line)
        
        # If no MODEL found, process entire file
        if not pdb_lines:
            with open(pdbqt_path, 'r') as f:
                for line in f:
                    if line.startswith('ATOM') or line.startswith('HETATM'):
                        pdb_line = line[:66] + '\n'
                        pdb_lines.append(pdb_line)
        
        with open(pdb_path, 'w') as f:
            f.writelines(pdb_lines)
        
        return True
        
    except Exception as e:
        print(f"  Error converting to PDB: {e}")
        return False


def create_complex_pdb(protein_pdb: Path, ligand_pdb: Path, complex_pdb: Path) -> bool:
    """Combine protein and docked ligand into a single PDB file."""
    try:
        with open(complex_pdb, 'w') as out:
            out.write(f"REMARK  Protein-Ligand Complex\n")
            out.write(f"REMARK  Protein: {protein_pdb.name}\n")
            out.write(f"REMARK  Ligand: {ligand_pdb.name}\n")
            
            # Write protein (skip waters and original ligand)
            with open(protein_pdb, 'r') as prot:
                for line in prot:
                    if line.startswith('ATOM'):
                        res_name = line[17:20].strip()
                        if res_name not in ['HOH', 'WAT']:
                            out.write(line)
            
            out.write("TER\n")
            
            # Write ligand as HETATM
            with open(ligand_pdb, 'r') as lig:
                for line in lig:
                    if line.startswith('ATOM') or line.startswith('HETATM'):
                        # Convert to HETATM and change residue name to LIG
                        new_line = "HETATM" + line[6:17] + "LIG" + line[20:]
                        out.write(new_line)
            
            out.write("END\n")
        
        return True
        
    except Exception as e:
        print(f"  Error creating complex: {e}")
        return False


# =============================================================================
# MAIN
# =============================================================================

def main():
    print("=" * 70)
    print("AutoDock Vina Docking - Top 5 EGFR Inhibitor Candidates")
    print("=" * 70)
    print(f"\nVina executable: {VINA_EXE}")
    print(f"Protein: {PROTEIN_PDB}")
    print(f"Binding site: ({CENTER_X}, {CENTER_Y}, {CENTER_Z})")
    print(f"Box size: {BOX_SIZE_X} x {BOX_SIZE_Y} x {BOX_SIZE_Z} Ã…")
    print(f"Exhaustiveness: {EXHAUSTIVENESS}")
    
    # Create output directories
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    pdbqt_dir = OUTPUT_DIR / "pdbqt"
    poses_dir = OUTPUT_DIR / "poses_pdb"
    complex_dir = OUTPUT_DIR / "complexes"
    logs_dir = OUTPUT_DIR / "logs"
    
    for d in [pdbqt_dir, poses_dir, complex_dir, logs_dir]:
        d.mkdir(exist_ok=True)
    
    # Prepare protein PDBQT
    protein_pdbqt = OUTPUT_DIR / "1M17_receptor.pdbqt"
    if not protein_pdbqt.exists():
        print("\n[1] Preparing protein receptor...")
        if not prepare_protein_pdbqt(PROTEIN_PDB, protein_pdbqt):
            print("ERROR: Failed to prepare protein")
            return
    else:
        print(f"\nâœ“ Using existing protein PDBQT: {protein_pdbqt}")
    
    # Process each candidate
    print("\n[2] Docking Top 5 Candidates...")
    print("-" * 70)
    
    results = []
    
    for i, rank in enumerate(TOP_5_RANKS, 1):
        mol_id = f"mol_{rank:03d}"
        smiles = TOP_5_SMILES[rank]
        
        print(f"\n[{i}/5] {mol_id} (Dock Rank {rank})")
        print(f"  SMILES: {smiles[:50]}...")
        
        # Load molecule from SDF
        sdf_path = LIGAND_DIR / f"{mol_id}.sdf"
        
        if sdf_path.exists():
            mol = Chem.SDMolSupplier(str(sdf_path), removeHs=False)[0]
        else:
            # Fallback: generate from SMILES
            print(f"  SDF not found, generating from SMILES...")
            mol = Chem.MolFromSmiles(smiles)
            if mol:
                mol = Chem.AddHs(mol)
                AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
                AllChem.MMFFOptimizeMolecule(mol)
        
        if mol is None:
            print(f"  ERROR: Could not load molecule")
            continue
        
        # Convert to PDBQT
        ligand_pdbqt = pdbqt_dir / f"{mol_id}.pdbqt"
        if not mol_to_pdbqt(mol, str(ligand_pdbqt)):
            print(f"  ERROR: PDBQT conversion failed")
            continue
        print(f"  âœ“ PDBQT prepared")
        
        # Run Vina docking
        output_pdbqt = pdbqt_dir / f"{mol_id}_docked.pdbqt"
        log_file = logs_dir / f"{mol_id}_vina.log"
        
        print(f"  Running Vina docking (exhaustiveness={EXHAUSTIVENESS})...")
        success, best_affinity, all_affinities = run_vina_docking(
            ligand_pdbqt, protein_pdbqt, output_pdbqt, log_file
        )
        
        if success:
            print(f"  âœ“ Best affinity: {best_affinity:.2f} kcal/mol")
            if len(all_affinities) > 1:
                print(f"    All poses: {', '.join(f'{a:.1f}' for a in all_affinities[:5])}")
            
            # Convert best pose to PDB
            pose_pdb = poses_dir / f"{mol_id}_pose1.pdb"
            pdbqt_to_pdb(output_pdbqt, pose_pdb, pose_num=1)
            print(f"  âœ“ Best pose saved: {pose_pdb.name}")
            
            # Create protein-ligand complex
            complex_pdb = complex_dir / f"{mol_id}_complex.pdb"
            create_complex_pdb(PROTEIN_PDB, pose_pdb, complex_pdb)
            print(f"  âœ“ Complex saved: {complex_pdb.name}")
            
            results.append({
                'rank': i,
                'dock_rank': rank,
                'mol_id': mol_id,
                'smiles': smiles,
                'affinity': best_affinity,
                'all_affinities': all_affinities,
                'pose_file': str(pose_pdb),
                'complex_file': str(complex_pdb)
            })
        else:
            print(f"  ERROR: Docking failed")
    
    # Summary
    print("\n" + "=" * 70)
    print("DOCKING RESULTS SUMMARY")
    print("=" * 70)
    
    if results:
        # Sort by affinity (lower is better)
        results.sort(key=lambda x: x['affinity'])
        
        print(f"\n{'Rank':<6}{'Mol ID':<10}{'Affinity':<12}{'Classification':<15}{'Complex File'}")
        print("-" * 70)
        
        for r in results:
            aff = r['affinity']
            if aff < -9.5:
                cls = "EXCELLENT"
            elif aff < -8.5:
                cls = "Good"
            elif aff < -7.0:
                cls = "Moderate"
            else:
                cls = "Weak"
            
            print(f"{r['rank']:<6}{r['mol_id']:<10}{aff:>8.2f} kcal/mol  {cls:<15}{Path(r['complex_file']).name}")
        
        # Save results CSV
        csv_path = OUTPUT_DIR / "vina_docking_results.csv"
        with open(csv_path, 'w') as f:
            f.write("Rank,Dock_Rank,Mol_ID,SMILES,Affinity_kcal_mol,Classification,Pose_File,Complex_File\n")
            for r in results:
                aff = r['affinity']
                if aff < -9.5:
                    cls = "EXCELLENT"
                elif aff < -8.5:
                    cls = "Good"
                elif aff < -7.0:
                    cls = "Moderate"
                else:
                    cls = "Weak"
                f.write(f"{r['rank']},{r['dock_rank']},{r['mol_id']},\"{r['smiles']}\",{aff:.2f},{cls},{r['pose_file']},{r['complex_file']}\n")
        
        print(f"\nâœ“ Results saved to: {csv_path}")
        
        print(f"\nðŸ“ Output Files:")
        print(f"  - PDBQT files: {pdbqt_dir}")
        print(f"  - Docked poses (PDB): {poses_dir}")
        print(f"  - Protein-ligand complexes: {complex_dir}")
        print(f"  - Docking logs: {logs_dir}")
    else:
        print("No successful docking results!")
    
    print("\n" + "=" * 70)
    print("Docking Complete!")
    print("=" * 70)


if __name__ == "__main__":
    main()
