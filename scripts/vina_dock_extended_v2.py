#!/usr/bin/env python3
"""
Extended Vina Docking for Remaining 15 Molecules
=================================================
Docks molecules not yet processed: ranks 4, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
(Already done: 1, 2, 3, 5, 10)
"""

import os
import csv
import subprocess
from pathlib import Path
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit import RDLogger
RDLogger.logger().setLevel(RDLogger.ERROR)

# =============================================================================
# CONFIGURATION
# =============================================================================

VINA_EXE = Path(r"C:\DENOVO\docking\vina_1.2.7_win.exe")
RECEPTOR_PDBQT = Path(r"C:\DENOVO\docking\vina_results\1M17_receptor.pdbqt")
DOCKING_FILE = Path(r"C:\DENOVO\results\top_docking_hits.csv")
OUTPUT_DIR = Path(r"C:\DENOVO\docking\vina_results_extended")
PROTEIN_PDB = Path(r"C:\DENOVO\docking\1M17.pdb")

# Binding site center (from Erlotinib in 1M17)
CENTER_X, CENTER_Y, CENTER_Z = 22.0, 0.3, 52.8
BOX_SIZE = 25

# Docking parameters
EXHAUSTIVENESS = 32
NUM_MODES = 9
ENERGY_RANGE = 3

# Molecules already docked (ranks from previous run)
ALREADY_DOCKED = {1, 2, 3, 5, 10}

# =============================================================================
# PDBQT CONVERSION (from working script)
# =============================================================================

def mol_to_pdbqt(mol: Chem.Mol, output_path: str) -> bool:
    """Convert RDKit molecule to PDBQT format for Vina."""
    try:
        # Add hydrogens if not present
        mol = Chem.AddHs(mol)
        
        # Generate 3D coordinates if not present
        if mol.GetNumConformers() == 0:
            AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
            AllChem.MMFFOptimizeMolecule(mol)
        
        # Compute Gasteiger charges
        AllChem.ComputeGasteigerCharges(mol)
        
        # Get conformer
        conf = mol.GetConformer()
        
        # AutoDock atom type mapping
        AD_TYPES = {
            'C': 'C', 'N': 'N', 'O': 'O', 'S': 'S', 'P': 'P',
            'F': 'F', 'Cl': 'Cl', 'Br': 'Br', 'I': 'I', 'H': 'H'
        }
        
        pdbqt_lines = []
        pdbqt_lines.append("REMARK  PDBQT generated by RDKit for AutoDock Vina\n")
        pdbqt_lines.append("ROOT\n")
        
        for i, atom in enumerate(mol.GetAtoms()):
            pos = conf.GetAtomPosition(i)
            symbol = atom.GetSymbol()
            
            # Get Gasteiger charge
            try:
                charge = float(atom.GetProp('_GasteigerCharge'))
                if not (-10 < charge < 10):  # Handle NaN or inf
                    charge = 0.0
            except:
                charge = 0.0
            
            # Get AutoDock atom type
            ad_type = AD_TYPES.get(symbol, 'C')
            
            # Handle special cases
            if symbol == 'C':
                if atom.GetIsAromatic():
                    ad_type = 'A'  # Aromatic carbon
            elif symbol == 'O':
                ad_type = 'OA'  # H-bond acceptor
            elif symbol == 'N':
                ad_type = 'NA'  # H-bond acceptor
            elif symbol == 'S':
                ad_type = 'SA'
            elif symbol == 'H':
                neighbors = [n.GetSymbol() for n in atom.GetNeighbors()]
                if any(n in ['N', 'O', 'S'] for n in neighbors):
                    ad_type = 'HD'  # Polar hydrogen
                else:
                    ad_type = 'H'
            
            # Format PDBQT ATOM line
            atom_name = f"{symbol}{i+1}"[:4]
            line = f"ATOM  {i+1:5d} {atom_name:<4s} LIG A   1    {pos.x:8.3f}{pos.y:8.3f}{pos.z:8.3f}  1.00  0.00    {charge:+6.3f} {ad_type:<2s}\n"
            pdbqt_lines.append(line)
        
        pdbqt_lines.append("ENDROOT\n")
        pdbqt_lines.append("TORSDOF 0\n")
        
        with open(output_path, 'w') as f:
            f.writelines(pdbqt_lines)
        
        return True
        
    except Exception as e:
        print(f"    Error converting to PDBQT: {e}")
        return False


def pdbqt_to_pdb(pdbqt_path: Path, pdb_path: Path, pose_num: int = 1) -> bool:
    """Convert PDBQT output to PDB format (extract specific pose)."""
    try:
        pdb_lines = []
        current_model = 0
        in_target_model = False
        
        with open(pdbqt_path, 'r') as f:
            for line in f:
                if line.startswith('MODEL'):
                    current_model += 1
                    if current_model == pose_num:
                        in_target_model = True
                        pdb_lines.append(line)
                elif line.startswith('ENDMDL'):
                    if in_target_model:
                        pdb_lines.append(line)
                        break
                elif in_target_model:
                    if line.startswith('ATOM') or line.startswith('HETATM'):
                        pdb_line = line[:66] + '\n'
                        pdb_lines.append(pdb_line)
                    elif line.startswith('ROOT') or line.startswith('ENDROOT') or line.startswith('BRANCH') or line.startswith('ENDBRANCH'):
                        continue
                    else:
                        pdb_lines.append(line)
        
        if not pdb_lines:
            with open(pdbqt_path, 'r') as f:
                for line in f:
                    if line.startswith('ATOM') or line.startswith('HETATM'):
                        pdb_line = line[:66] + '\n'
                        pdb_lines.append(pdb_line)
        
        with open(pdb_path, 'w') as f:
            f.writelines(pdb_lines)
        
        return True
        
    except Exception as e:
        print(f"    Error converting to PDB: {e}")
        return False


def create_complex_pdb(protein_pdb: Path, ligand_pdb: Path, complex_pdb: Path) -> bool:
    """Combine protein and docked ligand into a single PDB file."""
    try:
        with open(complex_pdb, 'w') as out:
            out.write(f"REMARK  Protein-Ligand Complex\n")
            
            with open(protein_pdb, 'r') as prot:
                for line in prot:
                    if line.startswith('ATOM'):
                        res_name = line[17:20].strip()
                        if res_name not in ['HOH', 'WAT']:
                            out.write(line)
            
            out.write("TER\n")
            
            with open(ligand_pdb, 'r') as lig:
                for line in lig:
                    if line.startswith('ATOM') or line.startswith('HETATM'):
                        new_line = "HETATM" + line[6:17] + "LIG" + line[20:]
                        out.write(new_line)
            
            out.write("END\n")
        
        return True
        
    except Exception as e:
        print(f"    Error creating complex: {e}")
        return False


# =============================================================================
# VINA DOCKING
# =============================================================================

def run_vina_docking(ligand_pdbqt, protein_pdbqt, output_pdbqt, log_file):
    """Run AutoDock Vina docking."""
    
    cmd = [
        str(VINA_EXE),
        "--receptor", str(protein_pdbqt),
        "--ligand", str(ligand_pdbqt),
        "--out", str(output_pdbqt),
        "--center_x", str(CENTER_X),
        "--center_y", str(CENTER_Y),
        "--center_z", str(CENTER_Z),
        "--size_x", str(BOX_SIZE),
        "--size_y", str(BOX_SIZE),
        "--size_z", str(BOX_SIZE),
        "--exhaustiveness", str(EXHAUSTIVENESS),
        "--num_modes", str(NUM_MODES),
        "--energy_range", str(ENERGY_RANGE)
    ]
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=600
        )
        
        with open(log_file, 'w') as f:
            f.write(f"Command: {' '.join(cmd)}\n\n")
            f.write("=== STDOUT ===\n")
            f.write(result.stdout)
            f.write("\n=== STDERR ===\n")
            f.write(result.stderr)
        
        # Parse results
        affinities = []
        in_results = False
        for line in result.stdout.split('\n'):
            if 'mode |' in line:
                in_results = True
                continue
            if '-----+' in line:
                continue
            if in_results and line.strip():
                parts = line.split()
                if len(parts) >= 2:
                    try:
                        mode = int(parts[0])
                        affinity = float(parts[1])
                        affinities.append(affinity)
                    except:
                        pass
        
        if affinities:
            return True, affinities[0], affinities
        else:
            return False, 0.0, []
            
    except subprocess.TimeoutExpired:
        return False, 0.0, []
    except Exception as e:
        print(f"    Docking error: {e}")
        return False, 0.0, []


# =============================================================================
# MAIN
# =============================================================================

# Setup directories
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
pdbqt_dir = OUTPUT_DIR / "pdbqt"
poses_dir = OUTPUT_DIR / "poses_pdb"
complex_dir = OUTPUT_DIR / "complexes"
logs_dir = OUTPUT_DIR / "logs"

for d in [pdbqt_dir, poses_dir, complex_dir, logs_dir]:
    d.mkdir(exist_ok=True)

print("=" * 80)
print("EXTENDED VINA DOCKING - REMAINING 15 MOLECULES")
print("=" * 80)
print(f"\nVina: {VINA_EXE}")
print(f"Receptor: {RECEPTOR_PDBQT}")
print(f"Binding site: ({CENTER_X}, {CENTER_Y}, {CENTER_Z})")
print(f"Exhaustiveness: {EXHAUSTIVENESS}")

# =============================================================================
# LOAD MOLECULES
# =============================================================================

molecules = []
with open(DOCKING_FILE, 'r') as f:
    reader = csv.DictReader(f)
    for row in reader:
        rank = int(row['Dock_Rank'])
        if rank not in ALREADY_DOCKED:
            molecules.append({
                'rank': rank,
                'smiles': row['SMILES'],
                'estimated': float(row['Affinity'])
            })

print(f"\nMolecules to dock: {len(molecules)}")
print(f"Already docked (skipping): {sorted(ALREADY_DOCKED)}")

# =============================================================================
# RUN DOCKING
# =============================================================================

results = []

for mol_data in molecules:
    rank = mol_data['rank']
    smiles = mol_data['smiles']
    estimated = mol_data['estimated']
    
    mol_id = f"mol_{rank:03d}"
    print(f"\n[{mol_id}] {smiles[:50]}...")
    
    # File paths
    ligand_pdbqt = pdbqt_dir / f'{mol_id}.pdbqt'
    output_pdbqt = pdbqt_dir / f'{mol_id}_docked.pdbqt'
    log_file = logs_dir / f'{mol_id}_vina.log'
    pose_pdb = poses_dir / f'{mol_id}_pose1.pdb'
    complex_pdb = complex_dir / f'{mol_id}_complex.pdb'
    
    # Create molecule from SMILES
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print(f"  FAILED: Invalid SMILES")
        results.append({'rank': rank, 'smiles': smiles, 'estimated': estimated, 'vina': None, 'status': 'invalid_smiles'})
        continue
    
    mol = Chem.AddHs(mol)
    
    # Generate 3D coordinates
    embed_result = AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
    if embed_result != 0:
        embed_result = AllChem.EmbedMolecule(mol, AllChem.ETKDG())
        if embed_result != 0:
            print(f"  FAILED: 3D embedding failed")
            results.append({'rank': rank, 'smiles': smiles, 'estimated': estimated, 'vina': None, 'status': '3d_failed'})
            continue
    
    AllChem.MMFFOptimizeMolecule(mol)
    
    # Prepare PDBQT
    print(f"  Preparing ligand...", end=' ')
    if not mol_to_pdbqt(mol, str(ligand_pdbqt)):
        print("FAILED (PDBQT conversion)")
        results.append({'rank': rank, 'smiles': smiles, 'estimated': estimated, 'vina': None, 'status': 'pdbqt_failed'})
        continue
    print("OK")
    
    # Run Vina
    print(f"  Running Vina docking (exhaustiveness={EXHAUSTIVENESS})...", end=' ')
    success, best_affinity, all_affinities = run_vina_docking(
        ligand_pdbqt, RECEPTOR_PDBQT, output_pdbqt, log_file
    )
    
    if success:
        print(f"OK → {best_affinity:.2f} kcal/mol")
        
        # Convert best pose to PDB
        pdbqt_to_pdb(output_pdbqt, pose_pdb, pose_num=1)
        
        # Create protein-ligand complex
        create_complex_pdb(PROTEIN_PDB, pose_pdb, complex_pdb)
        
        results.append({
            'rank': rank,
            'smiles': smiles,
            'estimated': estimated,
            'vina': best_affinity,
            'all_affinities': all_affinities,
            'status': 'success',
            'pose_file': str(pose_pdb),
            'complex_file': str(complex_pdb)
        })
    else:
        # Check log for error
        try:
            with open(log_file, 'r') as f:
                log_content = f.read()
                if 'Error' in log_content or 'error' in log_content:
                    error_lines = [l for l in log_content.split('\n') if 'error' in l.lower() or 'Error' in l]
                    print(f"FAILED: {error_lines[0][:50] if error_lines else 'Unknown error'}")
                else:
                    print("FAILED (no affinity result)")
        except:
            print("FAILED (docking error)")
        
        results.append({'rank': rank, 'smiles': smiles, 'estimated': estimated, 'vina': None, 'status': 'dock_failed'})

# =============================================================================
# SAVE RESULTS
# =============================================================================

results_file = OUTPUT_DIR / 'vina_extended_results.csv'
with open(results_file, 'w', newline='') as f:
    fieldnames = ['rank', 'smiles', 'estimated', 'vina', 'status', 'pose_file', 'complex_file']
    writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction='ignore')
    writer.writeheader()
    writer.writerows(results)

print("\n" + "=" * 80)
print("DOCKING COMPLETE")
print("=" * 80)

# Summary
success_results = [r for r in results if r['vina'] is not None]
failed_results = [r for r in results if r['vina'] is None]

print(f"\nSuccessful: {len(success_results)}/{len(molecules)}")
print(f"Failed: {len(failed_results)}")

if failed_results:
    print(f"\nFailed molecules:")
    for r in failed_results:
        print(f"  mol_{r['rank']:03d}: {r['status']}")

if success_results:
    # Sort by Vina affinity
    success_results.sort(key=lambda x: x['vina'])
    
    print(f"\n{'Rank':<8}{'Mol ID':<12}{'Estimated':<14}{'Vina Actual':<14}{'Classification'}")
    print("-" * 70)
    
    for r in success_results:
        aff = r['vina']
        if aff < -9.5:
            cls = "EXCELLENT"
        elif aff < -8.5:
            cls = "Good"
        elif aff < -7.0:
            cls = "Moderate"
        else:
            cls = "Weak"
        
        print(f"{r['rank']:<8}mol_{r['rank']:03d}     {r['estimated']:<14.2f}{aff:<14.2f}{cls}")

print(f"\n✓ Results saved to: {results_file}")

# =============================================================================
# COMBINE WITH ORIGINAL RESULTS
# =============================================================================

original_results_file = Path(r"C:\DENOVO\docking\vina_results\vina_docking_results.csv")
combined_file = OUTPUT_DIR / 'all_20_vina_results.csv'

if original_results_file.exists():
    print(f"\n[Combining with original 5 results...]")
    
    # Read original results
    all_results = []
    with open(original_results_file, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            all_results.append({
                'Rank': int(row['Dock_Rank']),
                'SMILES': row['SMILES'],
                'Estimated': float(row['Affinity_kcal_mol']),  # original used Estimated_Affinity
                'Vina': float(row['Affinity_kcal_mol']),
                'Status': 'success',
                'Pose_File': row.get('Pose_File', ''),
                'Complex_File': row.get('Complex_File', '')
            })
    
    # Add new results
    for r in success_results:
        all_results.append({
            'Rank': r['rank'],
            'SMILES': r['smiles'],
            'Estimated': r['estimated'],
            'Vina': r['vina'],
            'Status': 'success',
            'Pose_File': r.get('pose_file', ''),
            'Complex_File': r.get('complex_file', '')
        })
    
    # Sort by Vina affinity
    all_results.sort(key=lambda x: x['Vina'])
    
    # Save combined
    with open(combined_file, 'w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=['Rank', 'SMILES', 'Estimated', 'Vina', 'Status', 'Pose_File', 'Complex_File'])
        writer.writeheader()
        writer.writerows(all_results)
    
    print(f"✓ Combined results (all 20): {combined_file}")
    
    print(f"\n{'='*80}")
    print("ALL 20 MOLECULES - SORTED BY VINA AFFINITY")
    print("=" * 80)
    print(f"\n{'Vina Rank':<12}{'Mol ID':<12}{'Vina':<14}{'Classification'}")
    print("-" * 50)
    
    for i, r in enumerate(all_results, 1):
        aff = r['Vina']
        if aff < -9.5:
            cls = "EXCELLENT"
        elif aff < -8.5:
            cls = "Good"
        elif aff < -7.0:
            cls = "Moderate"
        else:
            cls = "Weak"
        
        print(f"{i:<12}mol_{r['Rank']:03d}     {aff:<14.2f}{cls}")

print("\n" + "=" * 80)
print("EXTENDED DOCKING COMPLETE!")
print("=" * 80)
